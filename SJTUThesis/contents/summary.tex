% !TEX root = ../main.tex

\chapter{全文总结} \label{ch:summary}

\section{主要结论}

本文工作是围绕基于静态单赋值中间语言的函数式编译器形式化验证进行的研究。
我们将函数式编译器中的CPS形式与SSA语言连接起来，并完成该转换过程的正确性验证，
从而为经验证的函数式编译器利用基于SSA的程序分析与优化提供方法。
本文设计了这样一种算法，它先将PCF程序转换为CPS形式，然后以CPS程序作为输入，输出LLVM风格的SSA程序。
为了验证转换算法的正确性，我们为源程序和目标程序提供了小步操作语义，
并基于模拟技术证明了转换过程的语义保存性质。
基于该经验证的编译过程，本文还构建了一个目标语言是LLVM IR的PCF编译器。
它先将读入的PCF程序编译到SSA目标语言，再进一步编译到Vellvm抽象语法树，得到LLVM IR程序。
其核心编译步骤的正确性是经过形式化验证的，
这为未来使经验证的函数编译器利用基于静态单赋值中间语言的编译器基础设施提供了基础。
本文工作解决了从CPS到SSA转换算法的形式化验证这一开放问题，为设计高效可靠的函数式编译器提供了新思路。

\section{研究展望}

当前函数式语言的设计中，程序项中使用有名字的变量表示方法。
在这种表示方法中，每个变量都有一个唯一的名称，通常是字符串或符号。
这种表示方法使代码项容易被人类理解，但在处理绑定变量时可能会引入名称冲突，需要进行重命名。
并且，这种表示方式使程序语言某些性质的证明更加困难。
如果在未来使用局部无命名表示（Locally Nameless Representation），变量就不具有全局唯一的名称，
而是使用一种特殊的标记：将绑定变量表示为de Bruijn形式的索引，从而避免了$\alpha$等价类的引入。
而自由变量保持为有名字的表示方式。如果能够实现这种改进，就可以避免对源程序使用$\alpha$重命名，
并且更方便地对代码项的类型性质进行证明。

由于本文在经验证的编译器领域实现了CPS与SSA的链接，在未来经验证的函数式编译器可以基于
本文的工作将更加现实的函数式语言编译到LLVM IR，从而复用其后端提供的各种工具。
PCF语言可以看作是函数式语言的核心，在未来的研究中可以将PCF语言扩展到更复杂的
工业函数式语言，完成工业函数式语言与LLVM的链接及编译正确性验证。
对于更复杂的函数式语言，进行扩展时其某些语法特性可以看作本文中PCF代码项语法的组合。
例如，有些函数式语言支持一对（Pair）类型的值$v$，即$(x,y)$，并可以使用相应的函数访问$v$的第一个或
第二个成员。若将访问第一个成员的函数记为$first$，则$first\; (x,y)=x$。
在本文的PCF语言中，只要将$\mathbf{fix}$的参数扩展为列表，就可以将$first$函数表示为
$\mathbf{fix}\; first\; [x,y]\; x$。
那么，如果一对类型的值为$(m,n)$，取其第一个元素的代码项$first\; (m,n)$用本文中的PCF代码项语法进行组合，
就可以记为
$\mathbf{let}\; x=m\; \mathbf{in}\; (\mathbf{let}\; y=n\; \mathbf{in}\; (first\; [x, y]))$。
许多函数式语言的语法特性都可以这样直接组合，这是因为它们可以用$\lambda$计算表示。
因此，本文工作中程序语言语义、转换算法设计及正确性验证的部分也可以经过组合方便地应用在
这些工业级函数式语言的大部分语法特性上。

我们还可以为函数式语言增添类型系统。设计函数式语言的类型规则（Typing Rule），
以定义类型良好（Well-typed）的代码项。这样一来，函数式程序非终止的状态就会严格限制在
可以进行下一步转换的情况。否则，它就不是类型良好的。
在无类型的语言中，我们可以用按值调用的不动点来实现递归。
对于有类型的语言，我们需要显式地支持递归来保证类型正确。
除了支持类型，我们还可以使函数式语言支持异常处理，并为CPS形式的函数增添异常处理器延续（Exception-handler Continuation）。
这些异常处理器延续实际上也是本文中介绍的局部延续（Local Continuation）。

经过上述扩展，本文工作可以应用在更为复杂的工业级函数式语言编译器中。
例如，如果将PCF源语言扩展到SML/NJ，对其从CPS到LLVM IR的转换过程正确性
进行形式化验证，就可以得到一个高可靠并基于LLVM后端的工业级函数式编译器。
不过，由于Vellvm现在已经将LLVM IR的语义从操作语义转向了基于ITree的语义~\cite{itree2019,itreevellvm2021}，
如果想要使用Vellvm的后续工作，可以着手于将操作语义与基于ITree的语义进行链接。
