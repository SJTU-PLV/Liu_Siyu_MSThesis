% !TEX root = ../main.tex

\chapter{全文总结} \label{ch:summary}

\section{主要结论}

本文工作是围绕基于静态单赋值中间语言的函数式编译器形式化验证进行的研究。
我们将函数式编译器中的CPS形式与SSA语言连接起来，并完成该转换过程的正确性验证，
从而为经验证的函数式编译器利用基于SSA的程序分析与优化提供方法。
本文设计了这样一种算法，它先将PCF程序转换为CPS形式，然后以CPS程序作为输入，输出LLVM风格的SSA程序。
为了验证转换算法的正确性，我们为源程序和目标程序提供了小步操作语义，
并基于模拟技术证明了转换过程的语义保存性质。
基于该经验证的编译过程，本文还构建了一个目标语言是LLVM IR的PCF编译器。
它先将读入的PCF程序编译到SSA目标语言，再进一步编译到Vellvm抽象语法树，得到LLVM IR程序。
其核心编译步骤的正确性是经过形式化验证的，
这为未来使经验证的函数编译器利用基于静态单赋值中间语言的编译器基础设施提供了基础。
本文工作解决了从CPS到SSA转换算法的形式化验证这一开放问题，为设计高效可靠的函数式编译器提供了新思路。

\section{研究展望}

当前函数式语言的设计中，程序项中使用有名字的变量表示方法。
在这种表示方法中，每个变量都有一个唯一的名称，通常是字符串或符号。
这种表示方法使代码项容易被人类理解，但在处理绑定变量时可能会引入名称冲突，需要进行重命名。
并且，这种表示方式使程序语言某些性质的证明更加困难。
如果在未来使用局部无命名表示（Locally Nameless Representation），变量就不具有全局唯一的名称，
而是使用一种特殊的标记：将绑定变量表示为de Bruijn形式的索引，从而避免了$\alpha$等价类的引入。
而自由变量保持为有名字的表示方式。如果能够实现这种改进，就可以避免对源程序使用$\alpha$重命名，
并且更方便地对代码项的类型性质进行证明。

由于本文在经验证的编译器领域实现了CPS与SSA的链接，在未来经验证的函数式编译器可以基于
本文的工作将更加现实的函数式语言编译到LLVM IR，从而复用其后端提供的各种工具。
PCF语言可以看作是函数式语言的核心，在未来的研究中可以将PCF语言扩展到更复杂的
工业函数式语言，完成工业函数式语言与LLVM的链接及编译正确性验证。
例如，如果将PCF源语言扩展到SML/NJ，对其从CPS到LLVM IR的转换过程正确性
进行形式化验证，就可以得到一个高可靠并基于LLVM后端的工业级函数式编译器。
不过，由于Vellvm现在已经将LLVM IR的语义从操作语义转向了基于ITree的语义~\cite{itree2019,itreevellvm2021}，
如果想要使用Vellvm的后续工作，可以着手于将操作语义与基于ITree的语义进行链接。
