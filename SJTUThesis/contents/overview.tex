
\chapter{基于SSA的函数式编译器概览} \label{sec:overview}

本文构建了一个从函数式程序到LLVM IR的编译器，并完成了对其核心编译步骤的形式化验证。
我们在Coq定理证明工具中完成了编译算法和形式化验证相关定理证明的实现。

我们选取PCF（Programming Computable Functions）语言作为该函数式编译器的源语言，因为它是函数式编程语言的核心，
被广泛应用于关于函数式语言的研究~\cite{plotkin1977lcf,ABRAMSKY2000409}。
尽管PCF是一种小规模的语言，但它是图灵完备的，即所有可计算的函数都可以表示为PCF程序。
把它作为该编译框架的源语言，不会使算法和验证过于复杂而无法完成，也能够说明关键问题。

在本章中，我们主要是从高层次的角度介绍了这个编译器原型，省略了转换算法细节和定理证明的详细信息。
该编译器读取PCF程序，并经过图~\ref{overview}中所示的几个编译步骤生成LLVM IR程序。
对于核心编译过程CPS转换及CPS到SSA的转换，我们对它们的正确性进行了形式化验证。
遵循第~\ref{sec:compcertbackend}节中所介绍的CompCert后端的验证框架，
我们通过建立源程序和目标程序之间的后向模拟完成了形式化验证。
本文中使用$\approx $符号表示源程序和目标程序的语义保存性质。
PCF、CPS和SSA的程序分别表示为$t_{pcf}$、$t_{cps}$和$t_{ssa}$。
通过对$t_{pcf}\approx t_{cps}$和$t_{cps}\approx t_{ssa}$的形式化证明，可以组合推导出$t_{pcf}\approx t_{ssa}$。

\begin{figure}[htbp]
    \centering
    \vspace{2ex}
    \includegraphics[width=0.8\linewidth]{figures/overview.pdf}
    \caption{PCF到LLVM编译链概览}\label{overview}
\end{figure}

\section{读入PCF文本}

首先使用PCF语法分析器（Parser）将文本形式的PCF程序提取为Coq中结构化的PCF抽象语法树。
为了分析文本信息从而提取PCF程序，我们需要先对文本进行逐词划分，然后按照语法规则组装起来。
具体来说，对于文本形式的PCF程序，
我们首先用词法分析器（Lexical Parser）将其解析为标记流（Tokens）。
随后，使用语法分析器（Syntax Parser）分析该标记流，生成Coq中直接风格PCF程序项的抽象语法树。
词法分析器和语法分析器在OCaml中实现，是利用词法和语法解析规则及对应操作生成的函数。
具体实现方法将在第~\ref{sec:pcfparser}节中介绍。
得到PCF源程序的抽象语法树后，我们就可以开始对其进行编译了。

\section{CPS转换}

如第\ref{sec:background}节中所言，函数式编程语言的编译器通常会将直接风格的程序转换为CPS形式，以获得显式的控制流。
我们已经得到了PCF程序的抽象语法树，但它是直接风格的程序，所以接下来需要使用CPS转换将其编译为CPS风格的程序。
将直接风格的PCF程序转换为CPS形式的算法主要由当前代码项和当前项被规约为某个值后要处理的下一个项决定。
我们使用一个特殊的顶层延续变量，把它应用到CPS程序的返回值上。
另外，我们为直接风格及CPS风格的PCF语言定义了小步操作语义，并证明了CPS转换的前向模拟性质。
关于该CPS转换算法及其正确性验证的详细信息将在第\ref{sec:cpstrans}节和第\ref{sec:cpsforward}节中进行讨论。

\section{从CPS到SSA}

该编译链中最关键的部分是从CPS风格的函数式程序到目标SSA程序的转换及验证。
这一编译步骤的源程序就是经过了CPS转换的PCF程序。
该转换过程的目标SSA语言是LLVM IR的简化版本，保留了其最基本的结构和程序语句。
我们在设计转换算法时，主要的根据是CPS程序与SSA程序结构上的对应关系。
通过该编译过程，输入的CPS程序项将被转换为一个包含主函数的SSA程序。

同样的，我们为这种SSA语言定义了小步操作语义，并证明了从CPS到SSA转换的前向模拟。
完成这一步证明后，我们将正向模拟组合起来，并完成了从源程序到SSA程序后向模拟的证明。
在第\ref{sec:cpsssatrans}节中将详细介绍该转换算法的设计和细节。
第\ref{sec:cpsssaforward}节中将进行CPS到SSA转换算法的形式化验证，并通过运行一个示例程序展示前向模拟的每一个关键步骤。

\section{从SSA到LLVM IR}

上一步中得到的SSA程序被转换为Vellvm中的抽象语法树，然后转换为LLVM IR程序文本。
在该编译链中，我们使用了经过验证的LLVM基础设施Vellvm~\cite{zakowski2021modular}。
利用其在Coq实现的LLVM IR的抽象语法树，我们可以进一步输出最终的LLVM IR程序。

由于我们使用的SSA语言是LLVM IR的简化版本，它保留了LLVM IR程序的基本结构，
可以方便地编译到Vellvm中的抽象语法树。这种SSA语言省略了LLVM IR中的大部分参数。
例如，函数定义在LLVM中非常复杂，有很多可选的参数，而本文中的SSA语言只保留了函数定义中必须指定的内容。
LLVM中的表达式类型多种多样，其中整数包括多种宽度的i16、i32等，
而本文的SSA语言简化为没有明确指定类型的无限宽自然数。
该编译过程的主要工作其实就是为这些被省略的参数选取正确的默认值。

\section{核心编译步骤的正确性验证}

构建该编译器的关键工作是从CPS到SSA的转换与验证。
由于函数式程序的CPS转换是函数式编译器中常用的编译过程，
我们也为CPS转换完成了形式化验证。所以，最终该编译器中经验证的
部分是从直接风格PCF到SSA的转换。我们证明了该核心编译过程的语义保存性质。

我们的形式化验证针对的是安全的源程序，即输入的PCF程序要么终止返回结果值、要么发散，不会出错。
并且，PCF程序不会卡在一个非终止的状态下无法进行下一步转换。
利用程序语言的小步操作语义，我们分别为CPS转换和CPS到SSA的转换证明了前向模拟性质。
其中，CPS转换程序内部执行步骤遵循的是多步模拟，而CPS到SSA的转换程序内部执行步骤遵循的是星形模拟。
我们为CPS程序定义了度量函数来防止出现星形模拟中的无限驻留问题。
将两步前向模拟组合起来可以得到从PCF源程序到SSA程序的前向模拟。
我们还证明了SSA程序的确定性，即同一个终止的SSA程序返回值是唯一确定的。
利用SSA程序的确定性和正向模拟性质，我们证明了PCF到SSA的后向模拟，
即SSA程序的行为是可接受的PCF程序行为。
这样，我们就验证了从PCF到SSA的核心编译过程的正确性。

完成了这样一个核心编译步骤经验证的基于SSA的PCF语言编译器，我们就用形式化的方法
将CPS与SSA联系在了一起，并为高可靠函数式编译器与主流编译器基础设施的连接提供了基础。
在接下来的两章中，我们将分别详细介绍关键编译步骤的转换算法和其语义保存性质的形式化验证。
该函数式编译器的具体代码实现将在第\ref{ch:implement}中介绍。